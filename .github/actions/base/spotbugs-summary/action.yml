name: SpotBugs Summary
description: Renders SpotBugs results as a summary table with clickable links

inputs:
  path:
    description: 'Glob pattern to find spotbugsXml.xml files'
    required: false
    default: '**/spotbugsXml.xml'

runs:
  using: composite
  steps:
    - name: Render SpotBugs Summary
      shell: python3 {0}
      continue-on-error: true
      env:
        GITHUB_REPO_URL: ${{ github.server_url }}/${{ github.repository }}/blob/${{ github.sha }}
      run: |
        import glob
        import os
        import xml.etree.ElementTree as ET

        repo_url = os.environ["GITHUB_REPO_URL"]
        summary_file = os.environ["GITHUB_STEP_SUMMARY"]

        SEVERITY = {"1": "üî¥ High", "2": "üü† Medium", "3": "üü° Low"}

        xml_files = glob.glob("**/spotbugsXml.xml", recursive=True)

        lines = ["## SpotBugs Results", ""]

        if not xml_files:
            lines.append("üì≠ No reports available")
            with open(summary_file, "a") as f:
                f.write("\n".join(lines) + "\n")
            raise SystemExit(0)

        lines.append("| Severity | File | Line | Bug Type | Message |")
        lines.append("|----------|------|------|----------|---------|")

        total = 0

        for xml_file in sorted(xml_files):
            # e.g. backend/target/spotbugsXml.xml -> backend
            module = os.path.dirname(xml_file).removesuffix("/target").removeprefix("./")

            try:
                tree = ET.parse(xml_file)
            except ET.ParseError:
                lines.append(f"| ‚ö†Ô∏è | Error parsing: {xml_file} | | | |")
                continue

            root = tree.getroot()

            # Resolve source root from the XML's SrcDir element instead of
            # hardcoding src/main/java.  The SrcDir is an absolute path like
            # /home/runner/work/repo/repo/backend/src/main/java ‚Äî we only
            # need the part relative to the module directory.
            src_suffix = "src/main/java"
            for sd in root.iter("SrcDir"):
                if sd.text:
                    parts = sd.text.split(f"/{module}/", 1)
                    if len(parts) == 2:
                        src_suffix = parts[1].rstrip("/")
                    break

            for bug in root.iter("BugInstance"):
                bug_type = bug.get("type", "")
                priority = bug.get("priority", "3")
                sev = SEVERITY.get(priority, "üü° Low")

                message = ""
                msg_el = bug.find(".//ShortMessage")
                if msg_el is not None and msg_el.text:
                    message = msg_el.text.strip()

                source_file = ""
                source_line = ""
                # Prefer primary SourceLine, fall back to first
                for sl in bug.iter("SourceLine"):
                    sp = sl.get("sourcepath", "")
                    ln = sl.get("start", "")
                    if not source_file and sp:
                        source_file = sp
                        source_line = ln
                    if sl.get("primary") == "true" and sp:
                        source_file = sp
                        source_line = ln
                        break

                if source_file and bug_type:
                    file_path = f"{module}/{src_suffix}/{source_file}"
                    class_name = os.path.basename(source_file)
                    display = f"{module}: {class_name}" if module else class_name
                    file_link = f"[`{display}`]({repo_url}/{file_path}#L{source_line})"
                    lines.append(f"| {sev} | {file_link} | {source_line} | `{bug_type}` | {message} |")
                    total += 1

        lines.append("")
        if total == 0:
            lines.append("‚úÖ No bugs found")
        else:
            lines.append(f"**Total: {total} bug(s)**")

        with open(summary_file, "a") as f:
            f.write("\n".join(lines) + "\n")
